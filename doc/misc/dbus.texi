\input texinfo   @c -*-texinfo-*-
@setfilename ../../info/dbus
@c %**start of header
@settitle Using of D-Bus
@c @setchapternewpage odd
@c %**end of header

@copying
Copyright @copyright{} 2007 Free Software Foundation, Inc.

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.2 or
any later version published by the Free Software Foundation; with no
Invariant Sections, with the Front-Cover texts being ``A GNU
Manual'', and with the Back-Cover Texts as in (a) below.  A copy of the
license is included in the section entitled ``GNU Free Documentation
License'' in the Emacs manual.

(a) The FSF's Back-Cover Text is: ``You have freedom to copy and modify
this GNU Manual, like GNU software.  Copies published by the Free
Software Foundation raise funds for GNU development.''

This document is part of a collection distributed under the GNU Free
Documentation License.  If you want to distribute this document
separately from the collection, you can do so by adding a copy of the
license to the document, as described in section 6 of the license.
@end quotation
@end copying

@dircategory Emacs
@direntry
* D-Bus: (dbus).                Using D-Bus in Emacs.
@end direntry

@node Top, Overview, (dir), (dir)
@top D-Bus integration in Emacs

This manual documents an API for usage of D-Bus in
Emacs.@footnote{D-Bus is not enabled by default.  You must run
@command{./configure --with-dbus} in Emacs' top level directory,
before you compile Emacs.}  D-Bus is a message bus system, a simple
way for applications to talk to one another.  An overview of D-Bus can
be found at @uref{http://dbus.freedesktop.org/}.

@insertcopying

@menu
* Overview::                    An overview of D-Bus.
* Inspection::                  Inspection of the bus names.
* Type Conversion::             Mapping Lisp types and D-Bus types.
* Synchronous Methods::         Calling methods in a blocking way.
* Signals::                     Sending and receiving signals.
* Errors and Events::           Errors and events.
* GNU Free Documentation License:: The license for this documentation.
@end menu

@node Overview
@chapter An overview of D-Bus
@cindex overview

D-Bus is an inter-process communication mechanism for applications
residing on the same host.  The communication is based on
@dfn{messages}.  Data in the messages is carried in a structured way,
it is not just a byte stream.

The communication is connection oriented to two kinds of message
buses: a so called @dfn{system bus}, and a @dfn{session bus}.  On a
given machine, there is always one single system bus for miscellaneous
system-wide communication, like changing of hardware configuration.
On the other hand, the session bus is always related to a single
user's session.

Every client application, which is connected to a bus, registers under
a @dfn{unique name} at the bus.  This name is used for identifying the
client application.  Such a unique name starts always with a colon,
and looks like @samp{:1.42}.

Additionally, a client application can register itself to a so called
@dfn{known name}, which is a series of identifiers separated by dots,
as in @samp{org.gnu.Emacs}.  If several applications register to the
same known name, these registrations are queued, and only the first
application which has registered for the known name is reachable via
this name.  If this application disconnects from the bus, the next
queued unique name becomes the owner of this known name.

An application can install one or several objects under its name.
Such objects are identified by an @dfn{object path}, which looks
similar to paths in a filesystem.  An example of such an object path
could be @samp{/org/gnu/Emacs/}.

Applications might send a request to an object, that means sending a
message with some data as input parameters, and receiving a message
from that object with the result of this message, the output
parameters.  Such a request is called @dfn{method} in D-Bus.

The other form of communication are @dfn{signals}.  The underlying
message is emitted from an object and will be received by all other
applications which have registered for such a signal.

All methods and signals an object supports are called @dfn{interface}
of the object.  Interfaces are specified under a hierarchical name in
D-Bus; an object can support several interfaces.  Such an interface
name could be @samp{org.gnu.Emacs.TextEditor} or
@samp{org.gnu.Emacs.FileManager}.


@node Inspection
@chapter Inspection of the bus names.
@cindex inspection

There are several basic functions which inspect the buses for
registered names.  Internally they use the basic interface
@samp{org.freedesktop.DBus}, which is supported by all objects of a bus.

@defun dbus-list-activatable-names
This function returns the D-Bus service names, which can be activated.
An activatable service is described in a service registration file.
Under GNU/Linux, such files are located at
@file{/usr/share/dbus-1/services/}.

The result is a list of strings, which is @code{nil} when there are no
activatable service names at all.
@end defun

@defun dbus-list-names bus
All service names, which are registered at D-Bus @var{bus}, are
returned.  The result is a list of strings, which is @code{nil} when
there are no registered service names at all.  Well known names are
strings like @samp{org.freedesktop.DBus}.  Names starting with
@samp{:} are unique names for services.

@var{bus} must be either the symbol @code{:system} or the symbol
@code{:session}.
@end defun

@defun dbus-list-known-names bus
Retrieves all services which correspond to a known name in @var{bus}.
A service has a known name if it doesn't start with @samp{:}.  The
result is a list of strings, which is @code{nil} when there are no
known names at all.

@var{bus} must be either the symbol @code{:system} or the symbol
@code{:session}.
@end defun

@defun dbus-list-queued-owners bus service
For a given service, registered at D-Bus @var{bus} under the name
@var{service}, all queued unique names are returned.  The result is a
list of strings, or @code{nil} when there are no queued names for
@var{service} at all.

@var{bus} must be either the symbol @code{:system} or the symbol
@code{:session}.  @var{service} must be a known service name as
string.
@end defun

@defun dbus-get-name-owner bus service
For a given service, registered at D-Bus @var{bus} under the name
@var{service}, the unique name of the name owner is returned.  The result is a
string, or @code{nil} when there exist no name owner of @var{service}.

@var{bus} must be either the symbol @code{:system} or the symbol
@code{:session}.  @var{service} must be a known service name as
string.
@end defun

@defun dbus-get-unique-name bus
The unique name, under which Emacs is registered at D-Bus @var{bus},
is returned as string.

@var{bus} must be either the symbol @code{:system} or the symbol
@code{:session}.
@end defun

@defun dbus-introspect bus service path
Objects can publish there interfaces to the D-Bus.  This function
returns all interfaces of @var{service}, registered at object path
@var{path} at bus @var{bus}.

@var{bus} must be either the symbol @code{:system} or the symbol
@code{:session}.  @var{service} must be a known service name, and
@var{path} must be a valid object path.  The last two parameters are
strings.  The result, the introspection data, is a string in XML
format. Example:

@example
(dbus-introspect
  :system "org.freedesktop.Hal"
  "/org/freedesktop/Hal/devices/computer")

@result{} "<!DOCTYPE node PUBLIC
    \"-//freedesktop//DTD D-BUS Object Introspection 1.0//EN\"
    \"http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd\">
    <node>
      <interface name=\"org.freedesktop.Hal.Device\">
        <method name=\"GetAllProperties\">
          <arg name=\"properties\" direction=\"out\" type=\"a@{sv@}\"/>
        </method>
        ...
        <signal name=\"PropertyModified\">
          <arg name=\"num_updates\" type=\"i\"/>
          <arg name=\"updates\" type=\"a(sbb)\"/>
        </signal>
      </interface>
      ...
    </node>"
@end example

This example informs us, that the service @code{org.freedesktop.Hal}
at object path @code{/org/freedesktop/Hal/devices/computer} offers the
interface @code{org.freedesktop.Hal.Device} (and 2 other interfaces
not documented here).  This interface contains the method
@code{GetAllProperties}, which needs no input parameters, but returns
as output parameter an array of dictionary entries (key-value pairs).
Every dictionary entry has a string as key, and a variant as value.

The interface offers also a signal, which returns 2 parameters: an
integer, and an array consisting of elements which are a struct of a
string and 2 boolean values.

Such type descriptions are called @dfn{signature} in D-Bus.  For a
discussion of D-Bus types and their Lisp representation see @ref{Type
Conversion}.@footnote{D-Bus signatures are explained in the D-Bus
specification
@uref{http://dbus.freedesktop.org/doc/dbus-specification.html#message-protocol-signatures}.
The interfaces of the service @code{org.freedesktop.Hal} are described
at
@uref{http://people.freedesktop.org/~david/hal-spec/hal-spec.html#interfaces}.}
@end defun


@node Type Conversion
@chapter Mapping Lisp types and D-Bus types.
@cindex type conversion

D-Bus method calls and signals accept usually several arguments as
parameters, either as input parameter, or as output parameter.  Every
argument belongs to a D-Bus type.

Such arguments must be mapped between the value encoded as a D-Bus
type, and the corresponding type of Lisp objects.  The mapping is
applied Lisp object @expansion{} D-Bus type for input parameters, and
D-Bus type @expansion{} Lisp object for output parameters.


@section Input parameters.

Input parameters for D-Bus methods and signals occur as arguments of a
Lisp function call.  The following mapping to D-Bus types is
applied, when the corresponding D-Bus message is created:

@example
@multitable {@code{t} and @code{nil}} {@expansion{}} {DBUS_TYPE_BOOLEAN}
@item Lisp type               @tab              @tab D-Bus type
@item
@item @code{t} and @code{nil} @tab @expansion{} @tab DBUS_TYPE_BOOLEAN
@item number                  @tab @expansion{} @tab DBUS_TYPE_UINT32
@item integer                 @tab @expansion{} @tab DBUS_TYPE_INT32
@item float                   @tab @expansion{} @tab DBUS_TYPE_DOUBLE
@item string                  @tab @expansion{} @tab DBUS_TYPE_STRING
@item list                    @tab @expansion{} @tab DBUS_TYPE_ARRAY
@end multitable
@end example

Other Lisp objects, like symbols or hash tables, are not accepted as
input parameter.

If it is necessary to use another D-Bus type, a corresponding type
symbol can be preceeded to the corresponding Lisp object. Basic D-Bus
types are represented by the type symbols @code{:byte},
@code{:boolean}, @code{:int16}, @code{:uint16}, @code{:int32},
@code{:uint32}, @code{:int64}, @code{:uint64}, @code{:double},
@code{:string}, @code{:object-path} and @code{:signature}.

@noindent
Example:

@lisp
(dbus-call-method ... @var{NUMBER} @var{STRING})
@end lisp

is equivalent to

@lisp
(dbus-call-method ... :uint32 @var{NUMBER} :string @var{STRING})
@end lisp

but different to

@lisp
(dbus-call-method ... :int32 @var{NUMBER} :signature @var{STRING})
@end lisp

A D-Bus compound type is always represented as list.  The car of this
list can be the type symbol @code{:array}, @code{:variant},
@code{:struct} or @code{:dict-entry}, which would result in a
corresponding D-Bus container.  @code{:array} is optional, because
this is the default compoud type for a list.

The objects being elements of the list are checked according to the
D-Bus compound type rules.

@itemize
@item An array must contain only elements of the same D-Bus type.
@item A variant must contain only one single element.
@item A dictionary entry must be element of an array, and it must
contain only a key-value pair of two element, with a basic type key.
@item There is no restriction for structs.
@end itemize

@noindent
Example:

@lisp
(dbus-send-signal ...
  :object-path STRING '(:variant :boolean BOOL)
  '(:array NUMBER NUMBER) '(:array BOOL :boolean BOOL)
  '(:struct BOOL :boolean BOOL BOOL
    (:array NUMBER NUMBER) (:array BOOL BOOL))
  '(:struct NUMBER NUMBER) '((:dict-entry NUMBER (NUMBER)))
  '(:array (:dict-entry NUMBER :int32 NUMBER)))
@end lisp


@section Output parameters.

Output parameters of D-Bus methods and signals are mapped to Lisp
objects.

@example
@multitable {DBUS_TYPE_OBJECT_PATH} {@expansion{}} {@code{t} or @code{nil}}
@item D-Bus type            @tab              @tab Lisp type
@item
@item DBUS_TYPE_BOOLEAN     @tab @expansion{} @tab @code{t} or @code{nil}
@item DBUS_TYPE_BYTE        @tab @expansion{} @tab number
@item DBUS_TYPE_UINT16      @tab @expansion{} @tab number
@item DBUS_TYPE_INT16       @tab @expansion{} @tab number
@item DBUS_TYPE_UINT32      @tab @expansion{} @tab number or float
@item DBUS_TYPE_INT32       @tab @expansion{} @tab number or float
@item DBUS_TYPE_UINT64      @tab @expansion{} @tab number or float
@item DBUS_TYPE_INT64       @tab @expansion{} @tab number or float
@item DBUS_TYPE_DOUBLE      @tab @expansion{} @tab float
@item DBUS_TYPE_STRING      @tab @expansion{} @tab string
@item DBUS_TYPE_OBJECT_PATH @tab @expansion{} @tab string
@item DBUS_TYPE_SIGNATURE   @tab @expansion{} @tab string
@item DBUS_TYPE_ARRAY       @tab @expansion{} @tab list
@item DBUS_TYPE_VARIANT     @tab @expansion{} @tab list
@item DBUS_TYPE_STRUCT      @tab @expansion{} @tab list
@item DBUS_TYPE_DICT_ENTRY  @tab @expansion{} @tab list
@end multitable
@end example

A float object in case of @code{DBUS_TYPE_UINT32},
@code{DBUS_TYPE_INT32}, @code{DBUS_TYPE_UINT64} and
@code{DBUS_TYPE_INT6432} is returned, when the C value exceeds the
Emacs number size range.

The resulting list of the last 4 D-Bus compound types contains as
elements the elements of the D-Bus container, mapped according to the
same rules.

The signal @code{PropertyModified}, discussed as example in
@ref{Inspection}, would offer as Lisp data the following object
(@var{BOOL} stands here for either @code{nil} or @code{t}):

@lisp
(@var{NUMBER} ((@var{STRING} @var{BOOL} @var{BOOL}) (@var{STRING} @var{BOOL} @var{BOOL}) ...))
@end lisp


@node Synchronous Methods
@chapter Calling methods in a blocking way.
@cindex method calls, synchronous
@cindex synchronous method calls

Methods can be called synchronously (@dfn{blocking}) or asynchronously
(@dfn{non-blocking}).  Currently, just synchronous methods are
implemented.

At D-Bus level, a method call consist of two messages: one message
which carries the input parameters to the object owning the method to
be called, and a reply message returning the resulting output
parameters from the object.

@defun dbus-call-method bus service path interface method &rest args
This function calls @var{method} on the D-Bus @var{bus}.  @var{bus} is
either the symbol @code{:system} or the symbol @code{:session}.

@var{service} is the D-Bus service name to be used.  @var{path} is the
D-Bus object path, @var{service} is registered at.  @var{interface} is
an interface offered by @var{service}.  It must provide @var{method}.

All other arguments args are passed to @var{method} as arguments.
They are converted into D-Bus types as described in @ref{Type
Conversion}.

The function returns the resulting values of @var{method} as a list of
Lisp objects, according to the type conversion rules described in
@ref{Type Conversion}.  Example:

@example
(dbus-call-method
  :session "org.gnome.seahorse" "/org/gnome/seahorse/keys/openpgp"
  "org.gnome.seahorse.Keys" "GetKeyField"
  "openpgp:657984B8C7A966DD" "simple-name")

@result{} (t ("Philip R. Zimmermann"))
@end example

If the result of the method call is just one value, the converted Lisp
object is returned instead of a list containing this single Lisp
object.  Example:

@example
(dbus-call-method
  :system "org.freedesktop.Hal"
  "/org/freedesktop/Hal/devices/computer"
  "org.freedesktop.Hal.Device" "GetPropertyString"
  "system.kernel.machine")

@result{} "i686"
@end example

With the @code{dbus-introspect} function it is possible to explore the
interfaces of @samp{org.freedesktop.Hal} service. It offers the
interfaces @samp{org.freedesktop.Hal.Manager} for the object at the
path @samp{/org/freedesktop/Hal/Manager} as well as the interface
@samp{org.freedesktop.Hal.Device} for all objects prefixed with the
path @samp{/org/freedesktop/Hal/devices}.  With the methods
@samp{GetAllDevices} and @samp{GetAllProperties}, it is simple to
emulate the @code{lshal} command on GNU/Linux systems:

@example
(dolist (device
          (dbus-call-method
            :system "org.freedesktop.Hal"
            "/org/freedesktop/Hal/Manager"
            "org.freedesktop.Hal.Manager" "GetAllDevices"))
  (message "\nudi = %s" device)
  (dolist (properties
            (dbus-call-method
              :system "org.freedesktop.Hal" device
              "org.freedesktop.Hal.Device" "GetAllProperties"))
    (message "  %s = %S"
             (car properties) (or (caar (cdr properties)) ""))))

@print{} "udi = /org/freedesktop/Hal/devices/computer
      info.addons = (\"hald-addon-acpi\")
      info.bus = \"unknown\"
      info.product = \"Computer\"
      info.subsystem = \"unknown\"
      info.udi = \"/org/freedesktop/Hal/devices/computer\"
      linux.sysfs_path_device = \"(none)\"
      power_management.acpi.linux.version = \"20051216\"
      power_management.can_suspend_to_disk = t
      power_management.can_suspend_to_ram = \"\"
      power_management.type = \"acpi\"
      smbios.bios.release_date = \"11/07/2001\"
      system.chassis.manufacturer = \"COMPAL\"
      system.chassis.type = \"Notebook\"
      system.firmware.release_date = \"03/19/2005\"
      ..."
@end example
@end defun


@node Signals
@chapter Sending and receiving signals.
@cindex signals

Signals are broadcast messages.  They carry input parameters, which
are received by all objects which have registered for such a signal.

@defun dbus-send-signal bus service path interface signal &rest args
This function is similar to @code{dbus-call-method}.  The difference
is, that there are no returning output parameters.

The function emits @var{signal} on the D-Bus @var{bus}.  @var{bus} is
either the symbol @code{:system} or the symbol @code{:session}.  It
doesn't matter whether another object has registered for @var{signal}.

@var{service} is the D-Bus service name of the object the signal is
emitted from.  @var{path} is the corresponding D-Bus object path,
@var{service} is registered at.  @var{interface} is an interface
offered by @var{service}.  It must provide @var{signal}.

All other arguments args are passed to @var{signal} as arguments.
They are converted into D-Bus types as described in @ref{Type
Conversion}.  Example:

@example
(dbus-send-signal
  :session "org.gnu.Emacs" "/org/gnu/Emacs"
  "org.gnu.Emacs.FileManager" "FileModified" "/home/albinus/.emacs")
@end example
@end defun

@defun dbus-register-signal bus service path interface signal handler
With this function, an application registers for @var{signal} on the
D-Bus @var{bus}.

@var{bus} is either the symbol @code{:system} or the symbol
@code{:session}.

@var{service} is the D-Bus service name used by the sending D-Bus
object.  It can be either a known name or the unique name of the D-Bus
object sending the signal.  In case of a unique name, signals won't be
received any longer once the object owning this unique name has
disappeared, and a new queued object has replaced it.

When @var{service} is @code{nil}, related signals from all D-Bus
objects shall be accepted.

@var{path} is the corresponding D-Bus object path, @var{service} is
registered at.  It can also be @code{nil} if the path name of incoming
signals shall not be checked.

@var{interface} is an interface offered by @var{service}.  It must
provide @var{signal}.

@var{handler} is a Lisp function to be called when the @var{signal} is
received.  It must accept as arguments the output parameters
@var{signal} is sending.  Example:

@example
(defun my-dbus-signal-handler (device)
  (message "Device %s added" device))

@result{} my-dbus-signal-handler

(dbus-register-signal
  :system "org.freedesktop.Hal" "/org/freedesktop/Hal/Manager"
  "org.freedesktop.Hal.Manager" "DeviceAdded"
  'my-dbus-signal-handler)

@result{} ((:system "org.freedesktop.Hal.Manager" "DeviceAdded")
    ("org.freedesktop.Hal" "/org/freedesktop/Hal/Manager"
     my-signal-handler))
@end example

As we know from the inspection data of interface
@code{org.freedesktop.Hal.Manager}, the signal @code{DeviceAdded}
provides one single parameter, which is mapped into a Lisp string.
The callback function @code{my-dbus-signal-handler} must define one
single string argument therefore.  Plugging an USB device to your
machine, when registered for signal @code{DeviceAdded}, will show you
which objects the GNU/Linux @code{hal} daemon adds.

@code{dbus-register-signal} returns a Lisp symbol, which can be used
as argument in @code{dbus-unregister-signal} for removing the
registration for @var{signal}.
@end defun

@defun dbus-unregister-signal object
Unregister @var{object} from the the D-Bus.  @var{object} must be the
result of a preceding @code{dbus-register-signal} call.
@end defun


@node Errors and Events
@chapter Errors and events.
@cindex errors
@cindex events

Input parameters of @code{dbus-call-method} and
@code{dbus-register-signal} are checked for correct D-Bus types. If
there is a type mismatch, the Lisp error @code{wrong-type-argument}
@code{D-Bus ARG} is raised.

All errors raised by D-Bus are signaled with the error symbol
@code{dbus-error}.  As usual, such an error can be trapped with a
@code{condition-case} form.  If possible, error messages from D-Bus
are appended to the @code{dbus-error}.

Incoming D-Bus messages are handled as Emacs events (see @pxref{Misc
Events, , , elisp}).  The generated event has this form:

@example
(dbus-event @var{bus} @var{service} @var{path} @var{interface} @var{member} @var{handler} &rest @var{args})
@end example

@var{bus} identifies the D-Bus the signal is coming from.  It is
either the symbol @code{:system} or the symbol @code{:session}.

@var{service} and @var{path} are the unique name and the object path
of the D-Bus object emitting the signal.  @var{interface} and
@var{member} denote the signal which has been sent.

@var{handler} is the callback function which has been registered for
this signal (see @pxref{Signals}).  When a @code{dbus-event} event
arrives, @var{handler} is called with @var{args} as arguments.

In order to inspect the @code{dbus-event} data, you could extend the
definition of the callback function in @ref{Signals}:

@example
(defun my-dbus-signal-handler (&rest args)
  (message "my-dbus-signal-handler: %S" last-input-event))
@end example

There exist convenience functions which could be called inside a
callback function in order to retrieve the information from the event.

@defun dbus-event-bus-name event
Returns the bus name @var{event} is coming from.
The result is either the symbol @code{:system} or the symbol @code{:session}.
@end defun

@defun dbus-event-service-name event
Returns the unique name of the D-Bus object @var{event} is coming from.
@end defun

@defun dbus-event-path-name event
Returns the object path of the D-Bus object @var{event} is coming from.
@end defun

@defun dbus-event-interface-name event
Returns the interface name of of the D-Bus object @var{event} is coming from.
@end defun

@defun dbus-event-member-name event
Returns the member name of of the D-Bus object @var{event} is coming
from.  It is either a signal name or a method name.
@end defun


@node GNU Free Documentation License
@appendix GNU Free Documentation License
@include doclicense.texi

@contents
@c End of dbus.texi
@bye

@ignore
   arch-tag: 2eeec19d-0caf-44e0-a193-329d7f9951d8
@end ignore
